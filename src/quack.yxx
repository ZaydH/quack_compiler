/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * quack.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include <vector>

  #include "ASTNode.h" // Abstract syntax tree
  #include "quack_program.h"
  #include "quack_class.h"
}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { Quack::Program** root }  /* Pass the quack program back to the tool */

%code{
    #include "lex.yy.h"
    #undef yylex
    /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    #define yylex lexer.yylex

}

%union {
    int   num;
    bool  boolean;
    char* str;
    Quack::Program* program;

    Quack::Class::Container* classes;
    Quack::Class* q_class;
    Quack::Method::Container* methods;
    Quack::Method* method;
    Quack::Param::Container* params;
    Quack::Param* param;

    AST::ASTNode* node;
    AST::Block* block;
    AST::RhsArgs* actual_args;
    AST::Typing* typing;

    std::vector<AST::TypeAlternative*>* type_alt;
}

// The following token values are actually used
%token <str> IDENT
%token <str> STRING_LIT
%token <num> INT_LIT
%token <boolean> BOOLEAN

// The following tokens don't need values
%token CLASS EXTENDS
%token DEF COMMA RETURN
%token IF ELIF ELSE
%token WHILE
%token NONE

%token TYPECASE

%token TRUE FALSE

// Abstract syntax tree nodes
%type <program> program
%type <classes> classes

%type <q_class> q_class
%type <str> super_class
%type <methods> methods
%type <method> method
%type <params> params all_params
%type <param> param
%type <str> var_type

%type <block> statement_block block if_alternatives
%type <node> stmt ifstmt lexpr rhs function_call return ident
%type <typing> lhs
%type <actual_args> actual_args rhs_args
%type <type_alt> type_alternative


// Precedence.  We are using an ambiguous expression grammar
// for compactness.  We declare operator precedence from lowest
// to highest, with associativity, e.g., MINUS is left_ associative
// so a-b-c is (a-b)-c and not a-(b-c).
%left  ','
%left  '='
%left  OR
%left  AND
// Out of place for C++ rules. This is because of rule in quack grammar logical operators have lower precedence than comparison
%precedence NOT NEG  // No direction since unary operator
%left  EQUALS
%left  ATLEAST ATMOST '>' '<'
%left  '-' '+'
%left  '*' '/'
%left  '.'
%%

/*
 * Root of the grammar is "program". A program consists of zero or more classes
 * and zero or more expressions.
 */
program: classes block  { *root = new Quack::Program($1, $2); } ;

/*
 * Classes are listed one after another.  They are stored in a singleton object
 * generally accessible for simplified type checking.
 */
classes: classes q_class  { $1->add($2);
                            $$=$1;
                          }
       | %empty           { $$ = Quack::Class::Container::singleton(); }
       ;

/* Parses a Quack Class */
q_class: CLASS IDENT '(' all_params ')' super_class '{' block methods '}'
            { $$ = new Quack::Class($2, $6, $4, $8, $9); }
       ;

/* Parameters are used in both the constructor of a class and the parameters of a method. */
all_params: %empty { $$ = new Quack::Param::Container(); }
          | params { $$ = $1; }
params: params ',' param {
                            $1->add($3);
                            $$=$1;
                         }
      | param  { $$ = new Quack::Param::Container();
                 $$->add($1);
               }
      ;
param: IDENT ':' IDENT  { $$ = new Quack::Param($1, $3); }
     ;

/* Super class is the extended class. */
super_class: EXTENDS IDENT { $$ = $2; }
           | %empty        { $$ = strdup(""); }
           ;

methods: method methods {
                          $2->add($1);
                          $$ = $2;
                        }
       | %empty { $$ = new Quack::Method::Container(); }
       ;
method: DEF IDENT '(' all_params ')' var_type statement_block
           { $$ = new Quack::Method($2, $6, $4, $7); }
      ;
var_type: ':' IDENT      { $$ = $2; }
        | %empty         { $$ = strdup(""); }
        ;

statement_block: '{' block '}' { $$ = $2; }
block: %empty                  { $$ = new AST::Block(); }
     | block stmt              { $1->append($2); $$ = $1; }
     ;

stmt: ifstmt          { $$ = $1; }
    | WHILE rhs statement_block    { $$ = new AST::While($2, $3); }
    | lhs '=' rhs ';'              { $$ = new AST::Assn($1, $3); } ;
    | rhs ';'         { $$ = $1; }
    | return ';'      { $$ = $1; }
    | TYPECASE rhs '{'type_alternative '}' { $$ = new AST::Typecase($2, $4); }
    ;
type_alternative: %empty              { $$ = new std::vector<AST::TypeAlternative*>(); }
                | type_alternative IDENT ':' IDENT statement_block
                                      { $1->emplace_back(new AST::TypeAlternative($2, $4, $5));
                                        $$ = $1; }
                ;
lhs: lexpr            { $$ = new AST::Typing($1, ""); }
   | lexpr ':' IDENT  { $$ = new AST::Typing($1, $3); }
   ;
lexpr: ident          { $$ = $1; }
     | rhs '.' ident  { $$ = new AST::ObjectCall($1, $3); }
     ;
ident: IDENT          { $$ = new AST::Ident($1); } ;
return: RETURN rhs    { $$ = new AST::Return($2); }
      | RETURN        { $$ = new AST::Return(new AST::NothingLit()); }
      ;

rhs: '(' rhs ')'       { $$ = $2; }
   | rhs '+' rhs       { $$ = new AST::BinOp("+", $1, $3); }
   | rhs '-' rhs       { $$ = new AST::BinOp("-", $1, $3); }
   | rhs '*' rhs       { $$ = new AST::BinOp("*", $1, $3); }
   | rhs '/' rhs       { $$ = new AST::BinOp("/", $1, $3); }
   | rhs '<' rhs       { $$ = new AST::BinOp("<", $1, $3); }
   | rhs '>' rhs       { $$ = new AST::BinOp(">", $1, $3); }
   | rhs AND rhs       { $$ = new AST::BoolOp("and", $1, $3); }
   | rhs OR rhs        { $$ = new AST::BoolOp("or", $1, $3); }
   | rhs EQUALS rhs    { $$ = new AST::BinOp("==", $1, $3); }
   | rhs ATMOST rhs    { $$ = new AST::BinOp("<=", $1, $3); }
   | rhs ATLEAST rhs   { $$ = new AST::BinOp(">=", $1, $3); }
   | '-' rhs %prec NEG { $$ = new AST::UniOp("-", $2); }
   | NOT rhs           { $$ = new AST::BoolOp("not", $2, nullptr); }
   | INT_LIT           { $$ = new AST::IntLit($1); }
   | rhs '.' function_call { $$ = new AST::ObjectCall($1, $3); }
   | TRUE              { $$ = new AST::BoolLit(true); }
   | FALSE             { $$ = new AST::BoolLit(false); }
   | NONE              { $$ = new AST::NothingLit(); }
   | STRING_LIT        { $$ = new AST::StrLit($1); }
   | lexpr             { $$ = $1; }
   | function_call     { $$ = $1; }
   ;
function_call: IDENT '(' actual_args ')' { $$ = new AST::FunctionCall($1, $3); }
actual_args: %empty        { $$ = new AST::RhsArgs(); }
           | rhs_args      { $$ = $1; }
           ;
rhs_args: rhs              { $$ = new AST::RhsArgs(); $$->add($1); }
        | rhs_args ',' rhs { $1->add($3); $$ = $1; }
        ;

ifstmt: IF rhs statement_block if_alternatives { $$ = new AST::If($2, $3, $4); } ;
if_alternatives:   %empty /* empty */          { $$ = new AST::Block(); }
               |   ELSE statement_block        { $$ = $2; };
               |   ELIF rhs statement_block if_alternatives
                                 {  $$ = new AST::Block();
                                    $$->append(new AST::If($2, $3, $4));
                                 }
               ;

%%
#include "messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}
