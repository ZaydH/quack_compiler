%top{
/* Quack scanner
 *
 * 2018 Fall version for RE/flex,
 * skeleton.
 *
 */

#define WHERE_AT ("at line " + std::to_string(lineno()) + ", column " + std::to_string(columno()))

#include <string>

#include "quack.tab.hxx"  /* Generated by bison. */
#include "messages.h"
%}

%{
    /* Externally visible file name --
     * for error messages.
     * or else find another way to dig it out.
     */
std::string yyfilename = "What file is this, anyway?";

    /* Some strings can't be matched in one gulp.  We need
     * a buffer in which to assemble them from parts.
     */
//static std::stringstream ss;
static std::string s_out;

/* Some long messages that don't fit well in the code below */

std::string BAD_ESC_MSG =
  "Illegal escape code; only \\\\, \\0, \\t, \\n, \\r, \\n are permitted";
std::string BAD_NL_STR =
  "Unclosed string?  Encountered newline in quoted string";
std::string BAD_EOF_IN_BLOCK_COMMENT = "End of file reached before end of block comment.";

%}


%option bison-cc bison-locations noyywrap
%option namespace=yy lexer=Lexer lex=yylex

  /* You'll probably want scanner states for both multi-line
   * comments and for triple-quote strings.  Do comments first,
   * because they're easier (you just throw away the text).  Then
   * do triple-quote strings.  You might consider doing the same for
   * normal strings with a single pair of double quotes, to avoid
   * writing a really ugly regex.  'comment' here is an example of
   * how to declare an exclusive scanner state.
   */
%x BLOCK_COMMENT LINE_COMMENT BLOCK_STRING SIMPLE_STRING
%%

  /* We start with some tokens that are not value-bearing,
   * i.e., the parser needs to know only which token was matched.
   */

  /* Multi-character punctuation with names */
==    { return parser::token::EQUALS; }
[<]=  { return parser::token::ATMOST; }
[>]=  { return parser::token::ATLEAST; }


   /* Single character punctuation.  Because a character
    * in C or C++ can be treated as an integer, Bison lets
    * us return a character as a token.
    * JFlex/Cup do not let you do this in Java.
    * Here are a few ... there are more.
    */
[-+*/{}:().,=;<>]  { return text()[0]; }

  /* Keywords are essentially another kind of punctuation,
   * but since they also match the identifier pattern, we
   * need to be sure we give their patterns *before* the
   * identifier pattern.  Most scanner generators work this
   * way, but WARNING for Python PLY users:  PLY prioritizes
   * by length of the regular expression!
   * Here are a couple of examples.
   */

class    { return parser::token::CLASS; }
extends  { return parser::token::EXTENDS; }
def      { return parser::token::DEF; }
return   { return parser::token::RETURN; }

typecase { return parser::token::TYPECASE; }

if       { return parser::token::IF; }
elif     { return parser::token::ELIF; }
else     { return parser::token::ELSE; }

while    { return parser::token::WHILE; }

and      { return parser::token::AND; }
or       { return parser::token::OR; }
not      { return parser::token::NOT; }

true     { return parser::token::TRUE; }
false    { return parser::token::FALSE; }

none     { return parser::token::NONE; }

   /* The following tokens are value-bearing:
    * We pass a value back to the parser by copying
    * it into the yylval parameter.  The parser
    * expects string values for identifiers and
    * string literals in yylval.str.  It expects integer
    * values for integer literals in yylval.num.
    * I'll give pattern for integer literals.
    * You'll need another for identifiers.  Remember to
    * 'strdup' the value returned by 'text()', or else it will
    * be clobbered by subsequent calls.
    */

[0-9]+                     { yylval.num = atoi(text()); return parser::token::INT_LIT; }
[[:alpha:]_][[:alnum:]_]*  { yylval.str = strdup(text()); return parser::token::IDENT; }

  /**
   * Block string
   */
\"\"\" { start(BLOCK_STRING); s_out = "";/*clear the stringstream */ }
<SIMPLE_STRING,BLOCK_STRING>{
<<EOF>>     { report::error("Invalid EOF in string on line " + std::to_string(lineno()));
              start(INITIAL);
              return EOF;
            }
}
<BLOCK_STRING>{
\"\"\"       { start(INITIAL);
               yylval.str = const_cast<char*>(s_out.c_str());
               return yy::parser::token::STRING_LIT;
             }
[^\"\"\"]+   { s_out += std::string(text()); }
}

  /**
   * Simple string (i.e., single quote only)
   *
   * Based on: https://stackoverflow.com/questions/5418181/flex-lex-encoding-strings-with-escaped-characters
   */
\" { start(SIMPLE_STRING);
     s_out = ""; /*clear the stringstream */
   }
<SIMPLE_STRING>{
[^\\"\n]+   { s_out += text(); }
\\0         { s_out += "\\0"; }
\\b         { s_out += "\\b"; }
\\t         { s_out += "\\t"; }
\\n         { s_out += "\\n"; }
\\r         { s_out += "\\r"; }
\\f         { s_out += "\\f"; }
\\\"        { s_out += "\\\""; }
'\\\\'      { s_out += "\\\\"; }
\\.         { std::string ss_err;
              ss_err = "Unknown escape character " + std::string(WHERE_AT);
              report::error(ss_err);
            }
\n          { std::string ss_err;
              ss_err = BAD_NL_STR + " " + WHERE_AT;
              report::error(ss_err);
              start(INITIAL);
            }
\"          { start(INITIAL);
              yylval.str = const_cast<char*>(s_out.c_str());
              return yy::parser::token::STRING_LIT;
            }
}

   /*
    * Handle both types of comments.  The two types will differ primarily in how they handle
    * New lines, EOF, and \*\/.
    */
"/*" { start(BLOCK_COMMENT); }
<BLOCK_COMMENT>{
<<EOF>>      { report::error("Unexpected EOF in block comment " + WHERE_AT); }
"*/"         { start(INITIAL); }
\n           /* Do Nothing */
}

"//" { start(LINE_COMMENT); }
   /* INITIAL Reserved word for default state. */
<LINE_COMMENT>{
<<EOF>>|\n   { start(INITIAL); }
}
  /* Anything beside a new line */
<BLOCK_COMMENT,LINE_COMMENT>{
. /* Do Nothing */
}


  /* You *can* write a one-line regular expression for matching a quoted string,
   * but you probably can't read it.  (I can't read mine.)  Scanner states and
   * simpler patterns are probably a better idea.
   * You almost certainly scanner states for triple quotes.
   * The tricky bit is catching errors, such as disallowed escape sequences
   * and unclosed quotes.
   */

  /* Ignore whitespace */
[ \t\n]*  {  }


.  {   std::stringstream ss_err;
       ss_err << "Unexpected character '" << text() << "' " << WHERE_AT;
       report::error(ss_err.str());
   }

<<EOF>>  { return EOF; }

%%

/* No main program here */

